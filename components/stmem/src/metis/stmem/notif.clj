(ns metis.stmem.notif
  (:require [metis.config.interface :as c]
            [metis.stmem.trans :as trans]
            [taoensso.carmine :as car :refer (wcar)]
            [clojure.string :as string]))

;;------------------------------
;; listeners 
;;------------------------------
(defonce listeners (atom {}))

(defn reg-pat
  ([m]
   (reg-pat c/config m))
  ([{t :stmem-trans s :stmem-key-sep :as config} m]
   (str (:mp-id m) s
        ((or (:struct m) :*)  t) s
        (if (:no-idx m) (trans/lpad config (:no-idx m)) (:* t)) s
        ((or (:func m) :*) t) s)))
   
(defn subs-pat
  "Generates subscribe patterns which matches depending on:
  
  **l2**
  
  * `container`
  * `definitions`
  
  **l3**
  
  * `0` ... `n`

  **l4**
  
  * `ctrl`
  * `state`
  * `definition`
  "
  ([m]
   (subs-pat c/config m))
  ([{t :stmem-trans s :stmem-notif-sep db :stmem-db :as config} m]
   (str "__keyspace" s db (:* t) "__:" (reg-pat config m) "*")))

(defn reg-key
  ([m]
   (reg-key c/config m))
  ([{t :stmem-trans s :stmem-notif-sep :as config} m]
   (when (and (map? m) (seq m))
     (str (reg-pat config m)
          (or (:level m) (trans/lpad config 0))))))

(defn gen-listener
  "Returns a listener for published keyspace **notif**ications. Don't forget
  to [[close-listener!]]

   Example:
  ```clojure
  ;; generate and close
  (close-listener! (gen-listener {:mp-id \"ref\"} msg->key))
  ```"
  ([m f]
   (gen-listener c/config m f))
  ([{{conn :spec :as config} :stmem-conn} m f]
   (let [pat (subs-pat config m)]
     (car/with-new-pubsub-listener conn {pat f} (car/psubscribe pat))))) 

(defn registered?
  "Checks if a `listener` is registered under
  the `listeners`-atom."
  ([m]
   (registered? c/config m))
  ([config m]
   (contains? @listeners (reg-key config m))))

(defn register
  "Generates and registers a listener in the `listeners` atom.  The cb!
  function dispatches depending on the result."
  ([m f]
   (register c/config m f))
  ([config m f]
   (let [reg-key (reg-key config m)]
     (if-not (registered? reg-key)
       {:ok (map? (swap! listeners assoc reg-key (gen-listener m f)))}
       {:ok true :warn "already registered"}))))

(defn close-listener
  "Closes the given listener generated by [[gen-listener]].

  Example:
  ```clojure
  ;; generate
  (def l (gen-listener {:mp-id \"ref\"} msg->map))
  ;; close 
  (close-listener! l)
  ```"
  [l]
  (car/close-listener l))

(defn clean-register
  "Closes and `de-registers` all `listeners` belonging to `mp-id` ."
  [m]
  (map (fn [[k v]]
         (when (string/starts-with? k (:mp-id m))
           (close-listener v)
           {:ok (map? (swap! listeners dissoc k))}))
       @listeners))

(comment
  
  ;;------------------------------
  ;; keyspace notification
  ;;------------------------------
(defn msg->map
  "Extracts the `key` from a published keyspace notification
  message (`pmessage`).

  Example:
  ```clojure
  (def msg [\"pmessage\"
           \"__keyspace@0*__:ref@*@*@ctrl*\"
           \"__keyspace@0__:ref@container@0@ctrl\"
           \"set\"])
  (st/msg->key msg)
  ;; \"ref@container@0@ctrl\"
  ```"
  [[k a b c]]
  (condp = (keyword k)
    :pmessage   (second (string/split a #":"))
    :psubscribe (mu/log ::msg->key :message "subscribed to pattern" :key a :command c)
    (mu/log ::msg->key :message "received" :key b :command c)))

;;------------------------------
;;register!, registered?, de-register!
;;------------------------------

(defn de-register!
  "De-registers the listener with the key `mp-id` in the `listeners`
  atom."
  ([mp-id struct no func]
   (de-register! mp-id struct no func "a"))
  ([mp-id struct no func level]
   (let [k (reg-key mp-id struct no func level)]
     (when (registered? k)
       (mu/log ::de-register! :message "will de-register" :key k)
       (close-listener! ((deref listeners) k))
       {:ok (map? (swap! listeners dissoc k))}))))

)