(ns metis.stmem.notif
  (:require [metis.config.interface :as c]
            [taoensso.carmine :as car :refer (wcar)]))
(comment
;;------------------------------
;; keyspace notification
;;------------------------------
(defn msg->key
  "Extracts the `key` from a published keyspace notification
  message (`pmessage`).

  Example:
  ```clojure
  (def msg [\"pmessage\"
           \"__keyspace@0*__:ref@*@*@ctrl*\"
           \"__keyspace@0__:ref@container@0@ctrl\"
           \"set\"])
  (st/msg->key msg)
  ;; \"ref@container@0@ctrl\"
  ```"
  [[k a b c]]
  (condp = (keyword k)
    :pmessage   (second (string/split a #":"))
    :psubscribe (mu/log ::msg->key :message "subscribed to pattern" :key a)
    (mu/log ::msg->key :message "received" :key b :command c)))

(defn subs-pat
  "Generates subscribe patterns which matches depending on:
  
  **l2**
  
  * `container`
  * `definitions`
  
  **l3**
  
  * `0` ... `n`

  **l4**
  
  * `ctrl`
  * `state`
  * `definition`
  "
  [mp-id a b c]
  (let [s (:stmem-notif-sep c/config)
        db  (:stmem-db c/config)]
    (str "__keyspace@" db "*__:" mp-id s a s b s c "*")))

(defn gen-listener
  "Returns a listener for published keyspace notifications. Don't forget
  to [[close-listener!]]

  Example:
  ```clojure
  ;; generate and close
  (close-listener! (gen-listener \"ref\" \"ctrl\" msg->key))
  ```"
  [mp-id a b c callback]
  (let [pat (subs-pat mp-id a b c)]
    (car/with-new-pubsub-listener (:spec (:stmem-conn c/config))
      {pat callback}
      (car/psubscribe pat))))  

(defn close-listener!
  "Closes the given listener generated by [[gen-listener]].

  Example:
  ```clojure
  ;; generate
  (def l (gen-listener \"ref\" \"ctrl\" msg->key))
  ;; close 
  (close-listener! l)
  ```"
  [l]
  (car/close-listener l))

;;------------------------------
;; listeners 
;;------------------------------
(defonce listeners (atom {}))

;;------------------------------
;;register!, registered?, de-register!
;;------------------------------
(defn reg-key
  "Generates a registration key for the listener atom.
  The `level` param allows to register more than one listener for one
  pattern."
  [mp-id struct no func level]
  (stu/vec->key  [mp-id struct no func level]))

(defn registered?
  "Checks if a `listener` is registered under
  the `listeners`-atom."
  [k]
  (contains? (deref listeners) k))

(defn register!
  "Generates and registers a listener under the key `mp-id` in the
  `listeners` atom.  The cb! function dispatches depending on the
  result."
  ([mp-id struct no func cb!]
   (register! mp-id struct no func cb! "a"))
  ([mp-id struct no func cb! level]
   (let [reg-key (reg-key mp-id struct no func level)]
     (if-not (registered? reg-key)
       {:ok (map?
             (swap! listeners assoc
                    reg-key
                    (gen-listener mp-id struct no func cb!)))}
       {:ok true :warn "already registered"}))))

(defn de-register!
  "De-registers the listener with the key `mp-id` in the `listeners`
  atom."
  ([mp-id struct no func]
   (de-register! mp-id struct no func "a"))
  ([mp-id struct no func level]
   (let [k (reg-key mp-id struct no func level)]
     (if (registered? k)
       (do
         (mu/log ::de-register! :message "will de-register" :key k)
         (close-listener! ((deref listeners) k))
         {:ok (map? (swap! listeners dissoc k))})
       {:ok true :warn "not registered"}))))

(defn clean-register!
  "Closes and `de-registers!` all `listeners` belonging to `mp-id` ."
  [mp-id]
  (map (fn [[k v]]
         (if (string/starts-with? k mp-id)
           (do
             (close-listener! v)
             {:ok (map? (swap! listeners dissoc k))})
           {:ok true :reason "unrelated"}))
       (deref listeners)))

)